# AI-Native å®Œæ•´æ•°æ®æµç¨‹è¯´æ˜

## ğŸ“Š æ€»ä½“æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          RSS åˆ° AI åˆ†æå®Œæ•´æµç¨‹                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  1. RSSæŠ“å–  â”‚ â”€â”€â–¶ â”‚  2. æ–‡ç« è§£æ  â”‚ â”€â”€â–¶ â”‚  3. æ•°æ®å­˜å‚¨  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                     â”‚                     â”‚
         â–¼                     â–¼                     â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ FeedManager  â”‚     â”‚ RSS Parser   â”‚     â”‚ Prisma ORM   â”‚
  â”‚              â”‚     â”‚ + Cheerio    â”‚     â”‚ + PostgreSQL â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                     â”‚                     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚  4. åŸºç¡€AI    â”‚
                            â”‚     åˆ†æ     â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ 5. æ·±åº¦åˆ†æ  â”‚
                            â”‚    é˜Ÿåˆ—å…¥é˜Ÿ  â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ 6. BullMQ    â”‚
                            â”‚    Worker    â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â–¼                 â–¼                 â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ 7. åˆ†æ®µåˆ†æ  â”‚ â”‚ 8. åæ€ä¼˜åŒ–  â”‚ â”‚ 9. ä¸ªæ€§åŒ–    â”‚
            â”‚  (Map-Reduce)â”‚ â”‚  (å¤šè½®è¿­ä»£)  â”‚ â”‚    è¯„åˆ†      â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚                 â”‚                 â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â–¼
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ 10. ç»“æœå­˜å‚¨ â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â–¼                 â–¼                 â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ 11. å‘é‡å­˜å‚¨ â”‚ â”‚ 12. çŸ¥è¯†å›¾è°± â”‚ â”‚ 13. ç”¨æˆ·åå¥½ â”‚
            â”‚              â”‚ â”‚    æ„å»º      â”‚ â”‚    å­¦ä¹       â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ 14. å‰ç«¯å±•ç¤º â”‚
                            â”‚    + æ¨è    â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ é˜¶æ®µè¯¦è§£

### é˜¶æ®µ 1: RSS æŠ“å– (Feed Fetching)

**å…¥å£**: `app/api/scheduler/trigger/route.ts` (å®šæ—¶ä»»åŠ¡æˆ–æ‰‹åŠ¨è§¦å‘)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/rss/feed-manager.ts`

```typescript
// æŠ“å–æµç¨‹
async function fetchFeeds() {
  // 1. è·å–æ‰€æœ‰æ´»è·ƒçš„è®¢é˜…æº
  const feeds = await db.feed.findMany({
    where: { active: true },
    orderBy: { priority: 'asc' }  // æŒ‰ä¼˜å…ˆçº§æ’åº
  });

  // 2. æ‰¹é‡æŠ“å–ï¼ˆæ”¯æŒå¹¶å‘æ§åˆ¶ï¼‰
  const results = await Promise.allSettled(
    feeds.map(feed => fetchSingleFeed(feed))
  );

  // 3. å¤„ç†ç»“æœå’Œé”™è¯¯
  return processResults(results);
}
```

**å…³é”®ç‰¹æ€§**:
- æ”¯æŒ HTTP ç¼“å­˜ (ETag, Last-Modified)
- è‡ªåŠ¨é‡è¯•ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
- ä¼˜å…ˆçº§è°ƒåº¦
- é”™è¯¯ç›‘æ§

**ç¯å¢ƒå˜é‡**:
```env
FETCH_TIMEOUT=30000       # è¯·æ±‚è¶…æ—¶
MAX_CONCURRENT_FETCHES=5  # å¹¶å‘æ•°
```

---

### é˜¶æ®µ 2: æ–‡ç« è§£æ (Parsing)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/rss/parser.ts`

```typescript
// è§£ææµç¨‹
async function parseFeed(xmlContent: string) {
  // 1. è§£æ XML/Atom/JSON Feed
  const feed = await parser.parseString(xmlContent);

  // 2. æå–æ–‡ç« åˆ—è¡¨
  const items = feed.items.map(item => ({
    title: item.title,
    link: item.link,
    content: item.content || item.description,
    publishedAt: item.pubDate,
    author: item.creator,
    // ...æ›´å¤šå­—æ®µ
  }));

  // 3. å†…å®¹æå–ï¼ˆé’ˆå¯¹ä¸å®Œæ•´çš„å†…å®¹ï¼‰
  const enriched = await extractFullContent(items);

  return enriched;
}
```

**å†…å®¹æå–** (`lib/rss/content-extractor.ts`):
- ä½¿ç”¨ Cheerio è§£æ HTML
- ç§»é™¤å¹¿å‘Šã€å¯¼èˆªç­‰æ— å…³å†…å®¹
- æå–æ­£æ–‡æ–‡æœ¬
- ä¿ç•™åŸºæœ¬æ ¼å¼

---

### é˜¶æ®µ 3: æ•°æ®å­˜å‚¨ (Storage)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/db.ts` (Prisma Client)

```typescript
// å­˜å‚¨æµç¨‹
async function saveEntries(entries: Entry[]) {
  // 1. è®¡ç®—å†…å®¹å“ˆå¸Œï¼ˆç”¨äºå»é‡ï¼‰
  const withHash = entries.map(entry => ({
    ...entry,
    contentHash: hashContent(entry.title + entry.content)
  }));

  // 2. æ‰¹é‡æ’å…¥ï¼ˆè‡ªåŠ¨å»é‡ï¼‰
  const created = await db.entry.createMany({
    data: withHash,
    skipDuplicates: true  // è·³è¿‡é‡å¤çš„å†…å®¹
  });

  // 3. æ›´æ–°è®¢é˜…æºç»Ÿè®¡
  await updateFeedStats(feedId, created.count);
}
```

**æ•°æ®åº“æ¨¡å‹** (`prisma/schema.prisma`):
```prisma
model Entry {
  id          String   @id @default(uuid())
  title       String
  url         String   @unique
  content     String?  @db.Text

  // å»é‡å­—æ®µ
  contentHash String   @unique @map("content_hash")

  // å…³è”
  feedId      String
  feed        Feed     @relation(fields: [feedId], references: [id])

  // AI åˆ†æå­—æ®µ
  aiSummary   String?  @map("ai_summary")
  aiKeywords  Json?    @map("ai_keywords")
  // ... æ›´å¤š AI å­—æ®µ

  createdAt   DateTime @default(now())
}
```

---

### é˜¶æ®µ 4: åŸºç¡€ AI åˆ†æ (Basic AI Analysis)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/ai/client.ts` + `lib/ai/queue.ts`

```typescript
// åŸºç¡€åˆ†ææµç¨‹
async function basicAnalysis(entryId: string) {
  // 1. è·å–æ–‡ç« å†…å®¹
  const entry = await db.entry.findUnique({ where: { id: entryId } });

  // 2. è°ƒç”¨ AI æœåŠ¡
  const aiService = getDefaultAIService();
  const result = await aiService.analyzeArticle(entry.content, {
    summary: true,      // ç”Ÿæˆæ‘˜è¦
    keywords: true,     // æå–å…³é”®è¯
    category: true,     // åˆ†ç±»
    sentiment: true,    // æƒ…æ„Ÿåˆ†æ
    importance: true,   // é‡è¦æ€§è¯„åˆ†
  });

  // 3. å­˜å‚¨ç»“æœ
  await db.entry.update({
    where: { id: entryId },
    data: {
      aiSummary: result.summary,
      aiKeywords: result.keywords,
      aiCategory: result.category,
      aiSentiment: result.sentiment,
      aiImportanceScore: result.importanceScore,
    }
  });
}
```

**é˜Ÿåˆ—å¤„ç†** (`lib/ai/queue.ts`):
- ä½¿ç”¨ BullMQ é˜Ÿåˆ—
- å¼‚æ­¥å¤„ç†ï¼Œé¿å…é˜»å¡
- å¤±è´¥è‡ªåŠ¨é‡è¯•

---

### é˜¶æ®µ 5: æ·±åº¦åˆ†æå…¥é˜Ÿ (Deep Analysis Queue)

**API è·¯ç”±**: `server/api/entries.ts`

```typescript
// è§¦å‘æ·±åº¦åˆ†æ
async function triggerDeepAnalysis(entryId: string, priority: number) {
  // 1. æ£€æŸ¥æ˜¯å¦å·²åˆ†æ
  const existing = await db.entry.findUnique({
    where: { id: entryId },
    select: { aiAnalyzedAt: true }
  });

  if (existing?.aiAnalyzedAt) {
    return { status: 'already_analyzed' };
  }

  // 2. æ·»åŠ åˆ°é˜Ÿåˆ—
  const jobId = await addDeepAnalysisJob({
    entryId,
    userId: ctx.userId,
    priority,
  });

  return { status: 'queued', jobId };
}
```

**é˜Ÿåˆ—é…ç½®** (`lib/queue/deep-analysis-processor.ts`):
```typescript
const queue = new Queue('deep-analysis', {
  connection: redis,
  defaultJobOptions: {
    attempts: 3,           // é‡è¯• 3 æ¬¡
    backoff: 'exponential', // æŒ‡æ•°é€€é¿
    removeOnComplete: 100,  // ä¿ç•™æœ€è¿‘ 100 ä¸ªæˆåŠŸä»»åŠ¡
    removeOnFail: 500,      // ä¿ç•™æœ€è¿‘ 500 ä¸ªå¤±è´¥ä»»åŠ¡
  }
});
```

---

### é˜¶æ®µ 6: BullMQ Worker å¤„ç† (Queue Worker)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/queue/deep-analysis-processor.ts`

```typescript
// Worker å¯åŠ¨
const worker = new Worker(
  'deep-analysis',
  async (job) => {
    const { entryId, userId } = job.data;

    try {
      // 1. è·å–æ–‡ç« å†…å®¹
      const entry = await getEntryWithContent(entryId);

      // 2. åˆå§‹åŒ–å·¥ä½œæµå¼•æ“
      const orchestrator = new WorkflowOrchestrator(llmService);

      // 3. æ‰§è¡Œåˆ†æå·¥ä½œæµ
      const result = await orchestrator.execute(
        'deep-analysis',
        { content: entry.content, metadata: entry },
        { entryId, userId }
      );

      // 4. å­˜å‚¨ç»“æœ
      await saveAnalysisResult(entryId, result);

      return result;
    } catch (error) {
      console.error('Analysis failed:', error);
      throw error;
    }
  },
  { connection: redis }
);
```

---

### é˜¶æ®µ 7: åˆ†æ®µåˆ†æ (Segmented Analysis - Map)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/ai/analysis/segmented-analyzer.ts`

```typescript
// åˆ†æ®µåˆ†ææµç¨‹
class SegmentedAnalyzer {
  async analyze(content: string, metadata: any) {
    // 1. æ™ºèƒ½åˆ†æ®µï¼ˆä¿æŒè¯­ä¹‰å®Œæ•´æ€§ï¼‰
    const segments = this.segment(content);
    // ç»“æœ: [
    //   { id: 1, content: "...", overlap: "..." },
    //   { id: 2, content: "...", overlap: "..." },
    //   ...
    // ]

    // 2. å¹¶è¡Œåˆ†æï¼ˆMap é˜¶æ®µï¼‰
    const analyzedSegments = await this.analyzeSegments(segments, metadata);
    // å¹¶å‘è°ƒç”¨ LLM åˆ†ææ¯ä¸ªæ®µè½

    // 3. èšåˆç»“æœï¼ˆReduce é˜¶æ®µï¼‰
    const aggregated = await this.aggregate(analyzedSegments);
    // åˆå¹¶ã€å»é‡ã€æ•´ç†

    return aggregated;
  }

  private segment(content: string): Segment[] {
    // 1. Markdown åˆ†è¯ï¼ˆmarked åº“ï¼‰
    const tokens = marked.lexer(content);

    // 2. æŒ‰æ®µè½/æ ‡é¢˜åˆ†ç»„
    const segments = [];
    let currentSegment = [];
    let tokenCount = 0;

    for (const token of tokens) {
      currentSegment.push(token);
      tokenCount += this.countTokens(token);

      // è¾¾åˆ°é˜ˆå€¼æ—¶åˆ‡åˆ†ï¼ˆçº¦ 2000 tokensï¼‰
      if (tokenCount >= 2000) {
        segments.push(this.wrapSegment(currentSegment));
        // ä¿ç•™é‡å éƒ¨åˆ†ï¼ˆçº¦ 200 tokensï¼‰é¿å…ä¸Šä¸‹æ–‡ä¸¢å¤±
        currentSegment = this.keepOverlap(currentSegment);
        tokenCount = this.countTokens(currentSegment);
      }
    }

    return segments;
  }
}
```

**è¾“å‡ºç¤ºä¾‹**:
```json
{
  "oneLineSummary": "è¿™ç¯‡æ–‡ç« æ¢è®¨äº†...",
  "summary": "è¯¦ç»†æ‘˜è¦...",
  "mainPoints": [
    {
      "point": "æ ¸å¿ƒè§‚ç‚¹1",
      "explanation": "è¯¦ç»†è§£é‡Š...",
      "importance": 9
    }
  ],
  "keyQuotes": [
    {
      "quote": "å¼•ç”¨æ–‡æœ¬...",
      "significance": "é‡è¦æ€§è¯´æ˜..."
    }
  ]
}
```

---

### é˜¶æ®µ 8: åæ€ä¼˜åŒ– (Reflection Engine)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/ai/analysis/reflection-engine.ts`

```typescript
// åæ€ä¼˜åŒ–æµç¨‹
class ReflectionEngine {
  async refine(originalContent: string, analysis: any, maxRounds: number = 3) {
    let currentAnalysis = analysis;
    let qualityScore = 0;

    for (let round = 0; round < maxRounds; round++) {
      // 1. è´¨é‡è¯„ä¼°ï¼ˆ5 ç»´åº¦ï¼‰
      const assessment = await this.assessQuality(originalContent, currentAnalysis);
      /*
      {
        "comprehensiveness": 8,  // å…¨é¢æ€§
        "accuracy": 9,           // å‡†ç¡®æ€§
        "depth": 7,              // æ·±åº¦æ€§
        "consistency": 10,       // ä¸€è‡´æ€§
        "objectivity": 8,        // å®¢è§‚æ€§
        "overall": 8.4
      }
      */

      qualityScore = assessment.overall;

      // 2. è´¨é‡è¾¾æ ‡åˆ™é€€å‡º
      if (qualityScore >= 8.5) {
        break;
      }

      // 3. ç”Ÿæˆæ”¹è¿›å»ºè®®
      const improvements = await this.generateImprovements(originalContent, currentAnalysis, assessment);
      /*
      {
        "issues": ["æ‘˜è¦ç¼ºå°‘å…³é”®ç‚¹X", "é‡è¦æ€§è¯„åˆ†åä½"],
        "suggestions": ["è¡¥å……Xè§‚ç‚¹", "æé«˜è¯„åˆ†"]
      }
      */

      // 4. åº”ç”¨æ”¹è¿›
      currentAnalysis = await this.applyImprovements(currentAnalysis, improvements);
    }

    return {
      ...currentAnalysis,
      qualityScore,
      reflectionRounds: maxRounds
    };
  }

  private async assessQuality(content: string, analysis: any) {
    const prompt = `
      è¯„ä¼°ä»¥ä¸‹åˆ†æçš„è´¨é‡ï¼ˆ1-10åˆ†ï¼‰ï¼š

      åŸæ–‡æ‘˜è¦ï¼š${content.slice(0, 1000)}...

      åˆ†æç»“æœï¼š
      ${JSON.stringify(analysis, null, 2)}

      è¯„ä¼°ç»´åº¦ï¼š
      1. å…¨é¢æ€§ï¼šæ˜¯å¦è¦†ç›–æ‰€æœ‰å…³é”®è¦ç‚¹
      2. å‡†ç¡®æ€§ï¼šæ˜¯å¦å‡†ç¡®åæ˜ åŸæ–‡è§‚ç‚¹
      3. æ·±åº¦æ€§ï¼šåˆ†ææ˜¯å¦æœ‰è¶³å¤Ÿæ·±åº¦
      4. ä¸€è‡´æ€§ï¼šå†…éƒ¨é€»è¾‘æ˜¯å¦ä¸€è‡´
      5. å®¢è§‚æ€§ï¼šæ˜¯å¦ä¿æŒå®¢è§‚ä¸­ç«‹

      è¯·è¿”å› JSON æ ¼å¼çš„è¯„åˆ†ã€‚
    `;

    return await this.llm.generate(prompt);
  }
}
```

---

### é˜¶æ®µ 9: ä¸ªæ€§åŒ–è¯„åˆ† (Personalized Scoring)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/ai/scoring/personal-scorer.ts`

```typescript
// ä¸ªæ€§åŒ–è¯„åˆ†æµç¨‹
class PersonalScorer {
  async calculateScore(analysis: any, userPrefs: UserPreference) {
    // 1. åŸºç¡€è¯„åˆ†ï¼ˆå®¢è§‚è´¨é‡ï¼‰
    const baseScore = (
      analysis.scoreDimensions.depth * 0.25 +
      analysis.scoreDimensions.quality * 0.25 +
      analysis.scoreDimensions.practicality * 0.25 +
      analysis.scoreDimensions.novelty * 0.25
    );

    // 2. ä¸ªæ€§åŒ–å› å­
    const personalFactors = await this.calculatePersonalFactors(analysis, userPrefs);
    /*
    {
      "topicMatch": 0.8,      // ä¸»é¢˜åŒ¹é…åº¦
      "depthMatch": 0.9,      // æ·±åº¦åå¥½åŒ¹é…
      "lengthMatch": 1.0,     // é•¿åº¦åå¥½åŒ¹é…
      "recencyBoost": 1.1,    // æ–°é²œåº¦åŠ æˆ
      "diversityBonus": 0.05  // å¤šæ ·æ€§å¥–åŠ±
    }
    */

    // 3. è®¡ç®—æœ€ç»ˆè¯„åˆ†
    const personalScore = baseScore * personalFactors.composite;

    return {
      personalScore: Math.min(10, Math.max(1, personalScore)),
      factors: personalFactors,
      breakdown: {
        baseScore,
        personalAdjustment: personalScore - baseScore
      }
    };
  }

  private async calculatePersonalFactors(analysis: any, userPrefs: UserPreference) {
    const factors = {
      topicMatch: 0.5,      // é»˜è®¤å€¼
      depthMatch: 1.0,
      lengthMatch: 1.0,
      recencyBoost: 1.0,
      diversityBonus: 0
    };

    // ä¸»é¢˜åŒ¹é…åº¦
    if (analysis.keywords && userPrefs.topicWeights) {
      const matchedTopics = analysis.keywords.filter(k => userPrefs.topicWeights[k]);
      if (matchedTopics.length > 0) {
        const avgWeight = matchedTopics.reduce((sum, k) =>
          sum + (userPrefs.topicWeights[k] || 0), 0) / matchedTopics.length;
        factors.topicMatch = Math.min(1.5, avgWeight);
      }
    }

    // æ·±åº¦åå¥½åŒ¹é…
    const preferredDepth = userPrefs.preferredDepth; // 'deep' | 'medium' | 'light'
    const analysisDepth = analysis.scoreDimensions?.depth || 5;

    if (preferredDepth === 'deep' && analysisDepth >= 8) {
      factors.depthMatch = 1.2;
    } else if (preferredDepth === 'light' && analysisDepth <= 6) {
      factors.depthMatch = 1.1;
    }

    // é•¿åº¦åå¥½åŒ¹é…
    const contentLength = analysis.contentLength || 0;
    const preferredLength = userPrefs.preferredLength;

    if (preferredLength === 'short' && contentLength < 2000) {
      factors.lengthMatch = 1.1;
    } else if (preferredLength === 'long' && contentLength > 5000) {
      factors.lengthMatch = 1.1;
    }

    // æ–°é²œåº¦åŠ æˆï¼ˆ7å¤©å†…ï¼‰
    const publishedAt = new Date(analysis.publishedAt);
    const daysSince = (Date.now() - publishedAt.getTime()) / (1000 * 60 * 60 * 24);
    if (daysSince < 7) {
      factors.recencyBoost = 1.1;
    }

    return {
      ...factors,
      composite: factors.topicMatch * factors.depthMatch *
                 factors.lengthMatch * factors.recencyBoost +
                 factors.diversityBonus
    };
  }
}
```

---

### é˜¶æ®µ 10: ç»“æœå­˜å‚¨ (Result Storage)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/queue/deep-analysis-processor.ts`

```typescript
// å­˜å‚¨åˆ†æç»“æœ
async function saveAnalysisResult(entryId: string, result: AnalysisResult) {
  // 1. æ›´æ–° Entry è¡¨
  await db.entry.update({
    where: { id: entryId },
    data: {
      aiOneLineSummary: result.oneLineSummary,
      aiMainPoints: result.mainPoints,
      aiKeyQuotes: result.keyQuotes,
      aiScoreDimensions: result.scoreDimensions,
      aiScore: result.aiScore,
      aiAnalysisModel: result.model,
      aiProcessingTime: result.processingTime,
      aiReflectionRounds: result.reflectionRounds,
      aiAnalyzedAt: new Date(),
    }
  });

  // 2. å­˜å‚¨å‘é‡ï¼ˆç”¨äºè¯­ä¹‰æœç´¢ï¼‰
  if (result.embedding) {
    await vectorStore.store(entryId, result.embedding, {
      category: result.category,
      keywords: result.keywords,
      summary: result.summary
    });
  }

  // 3. å‘é€é€šçŸ¥ï¼ˆå¯é€‰ï¼‰
  await notifyAnalysisComplete(entryId);
}
```

---

### é˜¶æ®µ 11: å‘é‡å­˜å‚¨ (Vector Storage)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/ai/embedding/pgvector-store.ts` æˆ– `memory-vector-store.ts`

```typescript
// å‘é‡å­˜å‚¨æµç¨‹
class PgVectorStore {
  async store(id: string, vector: number[], metadata: any) {
    // 1. å°†æ•°ç»„è½¬æ¢ä¸º pgvector æ ¼å¼
    const vectorString = `[${vector.join(',')}]`;

    // 2. æ’å…¥æ•°æ®åº“
    await db.$executeRaw`
      INSERT INTO embeddings (id, entry_id, vector, metadata, created_at)
      VALUES (${randomUUID()}, ${id}, ${vectorString}::vector, ${JSON.stringify(metadata)}, NOW())
      ON CONFLICT (entry_id) DO UPDATE SET
        vector = ${vectorString}::vector,
        metadata = ${JSON.stringify(metadata)},
        updated_at = NOW()
    `;
  }

  async search(queryVector: number[], limit: number, threshold: number) {
    const vectorString = `[${queryVector.join(',')}]`;

    // ä½™å¼¦ç›¸ä¼¼åº¦æœç´¢
    const results = await db.$queryRaw`
      SELECT
        entry_id,
        metadata,
        1 - (vector <=> ${vectorString}::vector) as similarity
      FROM embeddings
      WHERE 1 - (vector <=> ${vectorString}::vector) > ${threshold}
      ORDER BY vector <=> ${vectorString}::vector
      LIMIT ${limit}
    `;

    return results.map(r => ({
      entryId: r.entry_id,
      metadata: r.metadata,
      similarity: r.similarity
    }));
  }
}
```

---

### é˜¶æ®µ 12: çŸ¥è¯†å›¾è°±æ„å»º (Knowledge Graph)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/ai/knowledge/relation-extractor.ts`

```typescript
// å…³ç³»æŠ½å–æµç¨‹
class RelationExtractor {
  async findRelatedArticles(entryId: string, options: FindOptions) {
    const { limit = 5, relationType = 'all', minSimilarity = 0.75 } = options;

    // 1. è·å–ç›®æ ‡æ–‡ç« 
    const targetEntry = await db.entry.findUnique({
      where: { id: entryId },
      include: { aiAnalysis: true }
    });

    // 2. å‘é‡æœç´¢ç›¸ä¼¼æ–‡ç« 
    const similar = await vectorStore.search(
      targetEntry.contentEmbedding,
      limit * 3,
      minSimilarity
    );

    // 3. æ·±åº¦åˆ†æå…³ç³»ç±»å‹
    const relations = await Promise.all(
      similar.map(async (item) => {
        const relation = await this.analyzeRelation(targetEntry, item.entry);
        return {
          entryId: item.entry.id,
          relationType: relation.type,  // similar/prerequisite/extension/contradiction
          strength: relation.strength,  // 0-1
          reason: relation.reason
        };
      })
    );

    // 4. è¿‡æ»¤å’Œæ’åº
    const filtered = relations
      .filter(r => relationType === 'all' || r.relationType === relationType)
      .sort((a, b) => b.strength - a.strength)
      .slice(0, limit);

    // 5. å­˜å‚¨å…³ç³»
    await this.storeRelations(entryId, filtered);

    return filtered;
  }

  private async analyzeRelation(entry1: any, entry2: any) {
    const prompt = `
      åˆ†æä»¥ä¸‹ä¸¤ç¯‡æ–‡ç« ä¹‹é—´çš„å…³ç³»ï¼š

      æ–‡ç« Aï¼š${entry1.title}
      æ‘˜è¦ï¼š${entry1.aiOneLineSummary}
      å…³é”®è¯ï¼š${entry1.aiKeywords?.join(', ')}

      æ–‡ç« Bï¼š${entry2.title}
      æ‘˜è¦ï¼š${entry2.aiOneLineSummary}
      å…³é”®è¯ï¼š${entry2.aiKeywords?.join(', ')}

      è¯·åˆ¤æ–­å…³ç³»ç±»å‹ï¼ˆé€‰æ‹©æœ€ç›¸å…³çš„ä¸€ä¸ªï¼‰ï¼š
      1. similar - å†…å®¹ç›¸ä¼¼ï¼Œè®¨è®ºåŒä¸€è¯é¢˜
      2. prerequisite - Bæ˜¯Açš„å‰ç½®çŸ¥è¯†ï¼Œå»ºè®®å…ˆè¯»B
      3. extension - Bæ˜¯Açš„æ‰©å±•é˜…è¯»ï¼Œç›¸å…³ä¸»é¢˜æ·±å…¥
      4. contradiction - è§‚ç‚¹ç›¸åæˆ–å¯¹ç«‹

      è¿”å›JSONæ ¼å¼ï¼š
      {
        "type": "similar",
        "strength": 0.85,
        "reason": "ä¸¤ç¯‡æ–‡ç« éƒ½è®¨è®ºäº†..."
      }
    `;

    return await this.llm.generate(prompt);
  }

  async buildKnowledgeGraph(entryId: string, depth: number = 2) {
    const nodes = new Map();
    const edges = [];
    const visited = new Set();

    // BFS æ„å»ºå›¾è°±
    const queue = [{ id: entryId, layer: 0 }];
    nodes.set(entryId, { id: entryId, layer: 0 });

    while (queue.length > 0) {
      const current = queue.shift();
      if (visited.has(current.id) || current.layer >= depth) continue;

      visited.add(current.id);

      // æŸ¥æ‰¾ç›¸å…³æ–‡ç« 
      const related = await this.findRelatedArticles(current.id, {
        limit: 5,
        minSimilarity: 0.7
      });

      for (const rel of related) {
        const targetId = rel.entryId;

        // æ·»åŠ èŠ‚ç‚¹
        if (!nodes.has(targetId)) {
          nodes.set(targetId, {
            id: targetId,
            layer: current.layer + 1
          });
          queue.push({ id: targetId, layer: current.layer + 1 });
        }

        // æ·»åŠ è¾¹
        edges.push({
          source: current.id,
          target: targetId,
          label: rel.relationType,
          strength: rel.strength
        });
      }
    }

    return {
      nodes: Array.from(nodes.values()),
      edges,
      stats: {
        totalNodes: nodes.size,
        totalEdges: edges.length
      }
    };
  }
}
```

---

### é˜¶æ®µ 13: ç”¨æˆ·åå¥½å­¦ä¹  (Preference Learning)

**æ ¸å¿ƒæ–‡ä»¶**: `lib/ai/scoring/preference-tracker.ts`

```typescript
// åå¥½å­¦ä¹ æµç¨‹
async function updateUserPreferences(userId: string) {
  // 1. è·å–æœ€è¿‘çš„é˜…è¯»å†å²ï¼ˆæœ€è¿‘ 100 æ¡ï¼‰
  const history = await db.readingSession.findMany({
    where: { userId },
    include: {
      entry: {
        include: {
          feed: true,
          aiAnalysis: true
        }
      }
    },
    orderBy: { createdAt: 'desc' },
    take: 100
  });

  if (history.length < 5) {
    return; // æ•°æ®ä¸è¶³
  }

  // 2. åˆ†æä¸»é¢˜åå¥½
  const topicWeights = {};
  for (const session of history) {
    const keywords = session.entry.aiAnalysis?.keywords || [];
    const engagement = calculateEngagement(session); // åŸºäºå®Œæˆç‡ã€åœç•™æ—¶é—´

    for (const keyword of keywords) {
      if (!topicWeights[keyword]) {
        topicWeights[keyword] = 0;
      }
      topicWeights[keyword] += engagement;
    }
  }

  // å½’ä¸€åŒ–
  const maxWeight = Math.max(...Object.values(topicWeights));
  const normalizedWeights = {};
  for (const [topic, weight] of Object.entries(topicWeights)) {
    normalizedWeights[topic] = weight / maxWeight;
  }

  // 3. åˆ†æé˜…è¯»åå¥½
  const completedSessions = history.filter(h => h.isCompleted);
  const avgDwellTime = history.reduce((sum, h) => sum + h.dwellTime, 0) / history.length;
  const avgCompletion = history.reduce((sum, h) => sum + h.scrollDepth, 0) / history.length;

  let preferredDepth = 'medium';
  if (avgCompletion > 0.8 && avgDwellTime > 300) {
    preferredDepth = 'deep';
  } else if (avgCompletion < 0.3 || avgDwellTime < 60) {
    preferredDepth = 'light';
  }

  // 4. æ£€æµ‹è´Ÿåé¦ˆ
  const excludedTags = [];
  const quickSkips = history.filter(h => h.dwellTime < 30 && h.scrollDepth < 0.3);
  for (const session of quickSkips) {
    const tags = session.entry.aiAnalysis?.keywords || [];
    excludedTags.push(...tags);
  }

  // 5. è®¡ç®—å¤šæ ·æ€§åˆ†æ•°
  const uniqueTopics = new Set();
  for (const session of history) {
    const keywords = session.entry.aiAnalysis?.keywords || [];
    keywords.forEach(k => uniqueTopics.add(k));
  }
  const diversityScore = uniqueTopics.size / Math.max(history.length, 1);

  // 6. æ›´æ–°ç”¨æˆ·åå¥½
  await db.userPreference.upsert({
    where: { userId },
    create: {
      userId,
      topicWeights: normalizedWeights,
      preferredDepth,
      excludedTags: [...new Set(excludedTags)],
      stats: {
        totalEntries: history.length,
        avgCompletion,
        avgDwellTime,
        diversityScore
      }
    },
    update: {
      topicWeights: normalizedWeights,
      preferredDepth,
      excludedTags: [...new Set(excludedTags)],
      stats: {
        totalEntries: history.length,
        avgCompletion,
        avgDwellTime,
        diversityScore
      }
    }
  });
}
```

---

### é˜¶æ®µ 14: å‰ç«¯å±•ç¤ºå’Œæ¨è (Frontend Display)

**æ ¸å¿ƒç»„ä»¶**:

1. **é˜…è¯»è¡Œä¸ºè¿½è¸ª** (`hooks/useReadingTracking.ts`):
```typescript
function useReadingTracking({ entryId, enabled }) {
  const [scrollDepth, setScrollDepth] = useState(0);
  const [isActive, setIsActive] = useState(false);
  const startTime = useRef<Date>();

  useEffect(() => {
    if (!enabled) return;

    // å¼€å§‹è¿½è¸ª
    startTime.current = new Date();
    setIsActive(true);

    // ç›‘å¬æ»šåŠ¨
    const handleScroll = () => {
      const depth = calculateScrollDepth();
      setScrollDepth(depth);
    };
    window.addEventListener('scroll', handleScroll);

    // å®šæœŸä¸ŠæŠ¥ï¼ˆæ¯30ç§’ï¼‰
    const interval = setInterval(() => {
      if (scrollDepth >= 0.1) {
        trackReading({
          entryId,
          dwellTime: Math.floor((Date.now() - startTime.current.getTime()) / 1000),
          scrollDepth,
          isCompleted: scrollDepth >= 0.9
        });
      }
    }, 30000);

    // é¡µé¢å¸è½½æ—¶ä¸ŠæŠ¥
    const handleBeforeUnload = () => {
      trackReading({
        entryId,
        dwellTime: Math.floor((Date.now() - startTime.current.getTime()) / 1000),
        scrollDepth,
        isCompleted: scrollDepth >= 0.9
      });
    };
    window.addEventListener('beforeunload', handleBeforeUnload);

    return () => {
      window.removeEventListener('scroll', handleScroll);
      clearInterval(interval);
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [entryId, enabled]);

  return { scrollDepth, isActive };
}
```

2. **æ·±åº¦åˆ†æå¡ç‰‡** (`components/ai/DeepAnalysisCard.tsx`):
```typescript
function DeepAnalysisCard({ entryId }) {
  const { data: analysis, isLoading } = api.entries.getDeepAnalysis.useQuery({
    entryId
  });

  if (isLoading) return <LoadingSpinner />;
  if (!analysis) return null;

  return (
    <Card>
      <h3>AI åˆ†æ</h3>

      {/* è¯„åˆ†ä»ªè¡¨ç›˜ */}
      <ScoreDashboard score={analysis.aiScore} />

      {/* ä¸€å¥è¯æ€»ç»“ */}
      <p>{analysis.oneLineSummary}</p>

      {/* ä¸»è¦è§‚ç‚¹ */}
      <MainPoints points={analysis.mainPoints} />

      {/* å…³é”®å¼•ç”¨ */}
      <KeyQuotes quotes={analysis.keyQuotes} />

      {/* ç»´åº¦è¯„åˆ† */}
      <DimensionScores dimensions={analysis.scoreDimensions} />
    </Card>
  );
}
```

3. **ä¸ªæ€§åŒ–æ¨èæµ** (`components/feeds/PersonalizedFeed.tsx`):
```typescript
function PersonalizedFeed({ limit = 20 }) {
  const { data, fetchNextPage, hasNextPage } =
    api.analytics.getPersonalizedFeed.useInfiniteQuery(
      { limit, filters: { minScore: 6 } },
      { getNextPageParam: lastPage => lastPage.pagination.nextCursor }
    );

  const entries = data?.pages.flatMap(page => page.items) ?? [];

  return (
    <div>
      {entries.map(entry => (
        <PersonalizedEntryCard
          key={entry.id}
          entry={entry}
          personalScore={entry.personalScore}
        />
      ))}
      {hasNextPage && <Button onClick={fetchNextPage}>åŠ è½½æ›´å¤š</Button>}
    </div>
  );
}
```

4. **çŸ¥è¯†å›¾è°±å¯è§†åŒ–** (`components/knowledge/KnowledgeGraph.tsx`):
```typescript
function KnowledgeGraph({ entryId, depth = 2 }) {
  const { data: graph } = api.recommendations.getKnowledgeGraph.useQuery({
    entryId,
    depth
  });

  if (!graph) return null;

  return (
    <Card>
      <svg>
        {/* ç»˜åˆ¶èŠ‚ç‚¹ */}
        {graph.nodes.map(node => (
          <g key={node.id}>
            <circle cx={node.x} cy={node.y} r={25} />
            <text>{node.title}</text>
          </g>
        ))}
        {/* ç»˜åˆ¶è¾¹ */}
        {graph.edges.map(edge => (
          <line
            x1={edge.sourceX}
            y1={edge.sourceY}
            x2={edge.targetX}
            y2={edge.targetY}
            stroke={getEdgeColor(edge.label)}
          />
        ))}
      </svg>
    </Card>
  );
}
```

---

## â±ï¸ æ—¶é—´ä¼°ç®—

| é˜¶æ®µ | è€—æ—¶ | è¯´æ˜ |
|------|------|------|
| RSS æŠ“å– | 1-5ç§’/æº | å–å†³äºæºå“åº”é€Ÿåº¦ |
| æ–‡ç« è§£æ | 0.5-2ç§’/ç¯‡ | å†…å®¹æå–è€—æ—¶ |
| åŸºç¡€ AI åˆ†æ | 5-15ç§’/ç¯‡ | ä½¿ç”¨å¿«é€Ÿæ¨¡å‹ |
| æ·±åº¦åˆ†æ | 30-60ç§’/ç¯‡ | åŒ…å«åæ€å’Œè¯„åˆ† |
| å‘é‡å­˜å‚¨ | 1-2ç§’/ç¯‡ | pgvector æ’å…¥ |
| çŸ¥è¯†å›¾è°±æ„å»º | 10-30ç§’ | å–å†³äºæ·±åº¦ |

---

## ğŸ”§ é…ç½®é€‰é¡¹

### é˜Ÿåˆ—ä¼˜å…ˆçº§

```typescript
// é«˜ä¼˜å…ˆçº§ï¼šç”¨æˆ·ä¸»åŠ¨è§¦å‘çš„åˆ†æ
triggerDeepAnalysis({ entryId, priority: 1 });

// ä½ä¼˜å…ˆçº§ï¼šåå°è‡ªåŠ¨åˆ†æ
triggerDeepAnalysis({ entryId, priority: 10 });
```

### åæ€è½®æ•°

```typescript
// å¿«é€Ÿæ¨¡å¼ï¼ˆ1è½®åæ€ï¼‰
const reflection = new ReflectionEngine(llm);
await reflection.refine(content, analysis, 1);

// é«˜è´¨é‡æ¨¡å¼ï¼ˆ3è½®åæ€ï¼‰
await reflection.refine(content, analysis, 3);
```

### åˆ†æ®µå¤§å°

```typescript
const analyzer = new SegmentedAnalyzer(llm, {
  maxSegmentTokens: 2000,  // æ¯æ®µæœ€å¤§ tokens
  overlapTokens: 200,      // æ®µè½é‡å  tokens
  maxConcurrency: 3        // å¹¶å‘åˆ†ææ•°
});
```

---

## ğŸ“Š æ•°æ®æµè½¬å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              æ•°æ®æµè½¬å¯è§†åŒ–                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å¤–éƒ¨ RSS æº
     â”‚
     â”‚ HTTP GET (with ETag/Last-Modified)
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FeedManager â”‚ â—„â”€â”€â”€ Redis Cache (24h)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ RSS XML/JSON
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RSS Parser  â”‚ â—„â”€â”€â”€ Cheerio (content extraction)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ Entry[]
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Prisma ORM  â”‚ â”€â”€â–¶ PostgreSQL
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ entryId[]
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AI Queue    â”‚ â—„â”€â”€â”€ BullMQ + Redis
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ Job Data
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Worker      â”‚
â”‚ Process     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ AnalysisResult
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Entry Table â”‚       â”‚Vector Store â”‚       â”‚Relation     â”‚
â”‚             â”‚       â”‚(pgvector)   â”‚       â”‚Table        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                     â”‚                     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ tRPC API    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Frontend    â”‚
                    â”‚ Components  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ æ€»ç»“

å®Œæ•´çš„ AI-Native æµç¨‹ä» RSS æŠ“å–å¼€å§‹ï¼Œç»è¿‡ï¼š

1. **æ•°æ®è·å–** - FeedManager æŠ“å–å’Œè§£æ RSS
2. **åŸºç¡€å¤„ç†** - å­˜å‚¨ã€åŸºç¡€ AI åˆ†æ
3. **æ·±åº¦åˆ†æ** - é˜Ÿåˆ—åŒ–å¼‚æ­¥å¤„ç†
4. **æ™ºèƒ½å¢å¼º** - åˆ†æ®µåˆ†æã€åæ€ä¼˜åŒ–ã€ä¸ªæ€§åŒ–è¯„åˆ†
5. **çŸ¥è¯†ç»„ç»‡** - å‘é‡å­˜å‚¨ã€å…³ç³»æŠ½å–ã€å›¾è°±æ„å»º
6. **ç”¨æˆ·å­¦ä¹ ** - è¡Œä¸ºè¿½è¸ªã€åå¥½æ›´æ–°
7. **æ™ºèƒ½æ¨è** - ä¸ªæ€§åŒ–æ¨èæµã€å¯è§†åŒ–å±•ç¤º

æ¯ä¸ªé˜¶æ®µéƒ½ç»è¿‡ç²¾å¿ƒè®¾è®¡ï¼Œç¡®ä¿ï¼š
- **æ€§èƒ½**: å¹¶è¡Œå¤„ç†ã€é˜Ÿåˆ—åŒ–ã€ç¼“å­˜ä¼˜åŒ–
- **è´¨é‡**: åæ€æœºåˆ¶ã€å¤šè½®ä¼˜åŒ–
- **ä¸ªæ€§åŒ–**: ç”¨æˆ·åå¥½å­¦ä¹ ã€è¡Œä¸ºè¿½è¸ª
- **å¯æ‰©å±•**: æ¨¡å—åŒ–æ¶æ„ã€æä¾›å•†æŠ½è±¡
